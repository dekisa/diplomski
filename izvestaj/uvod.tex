dodati tabelu registara PIO
dodati opis linuksa
dodati opis buildroot
dodati opis device tree model
dodati proceduru tersiranja
dodati device tree u dodatak

\section{Uvod}
U ovom radu je na DE1-SoC razvojnom sistemu implementiran jednostavan hardver u FPGA, portovan je Linuks operativni sistem i napisan je drajver za pristup registrima i prihvatanje prekida iz FPGA. 

\subsection{Sistemi na čipu sa FPGA}
Sa sve većim mogućnostima namenskih sistema došlo je do popularizacije sistema na čipovima (SoC - \textit{System on Chip}) koji integrišu mikroprocesore sa više jezgara, memorije na čipu, mnogobrojne periferije i transivere, kao i FPGA (\textit{Field Programmable Gate Array}).

Ova tehnologija daje dizajneru sistema veliku slobodu i mogućnosti, a zadršava se klasičan postupak projektovanja namenskih sistema. Uz to se ostvaruje veća integracija, manja potrošnja, manja površina štampane ploče (PCB - \textit{Printed Circuit Board}) i veći protok podataka između procesora i FPGA dela. 

Uobičajena primena ovih sistema je implementacija specifičnih akceleratora koji ubrzavaju izvršavanje algoritama i implementacija specifičnih programabilnih interfejsa ka spoljnom svetu. Sve zrelije tehnologije kao što su OpenCL, Vivado HLS, Matlab HDL Coder omogućavaju kompatibilnost dizajna softvera na visokom nivou i implementiranog hardvera na niskom nivou.

SoC FPGA sistemi najčešće sadrže ARM mikroprocesor. Aplikacije na mikroprocesoru bez operativnog sistema (\textit{baremetal application}) nude jednostavno pisanje koda i uštedu na resursima. Za kompleksnije aplikacije koriste se operativni sistemi (OS) i time se olakšava integrisanje mrežnih protokola, rad sa multimedijalnim sadržajima, kriptografskim bibliotekama kao i mnoge druge mogućnosti koje su dostupne kao \textit{open-source} softver. Kada je potrebno garantovati reakciju u određenom vremenu na neki spoljni događaj veliki operativni sistemi nisu dobro rešenje i koriste operativni sistemi u realnom vremenu (RTOS - \textit{Real time operating system}).

Hardver u FPGA se projektuje upotrebom nekog od dva popularna jezika za opis hardvera - Verilog i VHDL (\textit{Very High Speed Integrated Circuit Hardwer Description Language}). Pored toga neophodni su softverski alati za specifični uređaj, koje obezbeđuje sam proizvođač uređaja. Dodatno ovi alati olakšavaju dizajn upotrebom IP(\textit{Intelectual Property}) blokova, generisanjem raznih izlaznih fajlova koji opisuju projektovani hardver na standardni način i koriste se prilikom razvoja softvera.

\subsection{Opis DE1-SoC}

U ovom radu korišćen je DE1-SoC razvojni sistem koji se vrlo često upotrebljava u edukativne svrhe. Razvojni sistem je zasnovan na čipu iz familije Cyclone V kompanije Intel (ranije Altera).

U nastavku su navedene samo osobine razvojnog sistema koje se tiču ovog rada, a detaljniji opis se moze pronaći u dokumentu zvaničnoj dokumentaciji proizvođača []
dodati referencu: \verb+https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&CategoryNo=205&No=836&PartNo=4 +
DE1-SoC User Manual(rev.E Board)
Terasic
\begin{itemize}
\item Sistem na čipu Cyclone V \texttt{5CSEMA5F31}
\item Memorija 1GB (2x256Mx16) DDR3 SDRAM povezana na HPS
\item Slot za Micro SD karticu povezan na HPS
\item UART na USB (USB Mini-B konektor)
\item 5 debaunsiranih tastera (FPGA x4, HPS x1)
\item 11 LE dioda (FPGA x10, HPS x 1)
\item 12V DC napajanje
\end{itemize}

\subsection{Opis Altera Cyclone 5}
Altera Cyclone V je SoC FPGA koji se sastoji od dva dela(slika): procesorski deo (HPS -  \textit{Hard processor System}) i programabilni FGPA deo. HPS se sastoji od MPU (\textit{Microprocessor unit}) sa ARM Cortex-A9 MPCore sa dva jezgra i sledećih modula: kontroleri memorije, memorije, periferije, sistem interkonekcije, debug moduli, PLL moduli. FPGA deo se sastoji od sledećih delova: FPGA programabilna logika (\textit{look-up} tabele, RAM memorije, mnozači i rutiranje), kontrolni blok, PLL, kontroler memorije.

Svaki pin kućista je povezan na samo jedan od ova dva dela sistema, tako da HPS deo i FPGA deo ne mogu međusobno razmenjivati pinove.

\subsubsection{Konfigurisanje FPGA i pokretanje HPS}
Pri pokretanju HPS (boot) može da učita program iz FPGA dela, iz eksterne \textit{flash} memorije ili preko JTAG. FPGA ima mogućnost da se konfiguriše softverski iz HPS korišćenjem periferije FPGA Manager ili spoljnim programatorom. Kombinacije ovih mogucnosti daju nekoliko scenarija:
\begin{itemize}
\item nezavisno konfigurisanje FPGA i pokretanje HPS
\item konfigurisanje FPGA, zatim pokretanje HPS iz memorije koja se nalazi u FPGA
\item pokretanje HPS, zatim konfigurisanje FPGA iz HPS
\end{itemize}
DE1-SoC razvojni sistem dolazi sa integrisanim programatorom kojem se pristupa preko USB porta. Moguće je podesiti konfigurisanje FPGA spolja ili iz HPS upotrebom prekidača MSEL, dok se HPS uvek pokreće iz \textit{flash} memorije SD kartice.
(dodati tableu 3-2 iz de1soc user guide)

\subsubsection{HPS-FPGA interfejsi}
HPS-FPGA interfejsi su komunikacioni kanali između HPS i FPGA dela. U nastavku su nabrojani i opisani HPS-FPGA interfejsi:
\begin{itemize}
\item  FPGA-to-HPS bridge - magistrala visokih preformansi konfigurabilne sirine od 32,64 ili 128 bita. Na ovoj magistrali je FPGA master. Ovaj interfejs otkriva FPGA masterima ceo adresni prostor HPS dela.
\item HPS-to-FPGA bridge - magistrala visokih preformansi konfigurabilne sirine od 32,64 ili 128 bita. Na ovoj magistrali je HPS master a u FPGA se nalazi slave.
\item Lightweight HPS-to-FPGA - magistrala sirine 32 bita. HPS je master na ovoj magistrali. Ovaj interfejs manjeg protoka je namenjen za pristup statusnim i kontrolnim registrima periferijama implementiranim u FPGA delu.
\item FPGA manager - HPS periferja koja komunicira sa FPGA delom prilikom konfiguracije ili pokretanja (boot)
\item Prekidi - mogucnost povezivanja prekida iz FPGA na HPS kontroler prekida
\item HPS debug interfejs - omogućava da se debug mogućnosti prošire i na FPGA deo
\end{itemize}

Interfejsi koji su produžetak AXI magistrale na FPGA deo su FPGA-to-HPS bridge, HPS-to-FPGA bridge i Lightweight HPS-to-FPGA. Za povezivanje na ovu magistralu sa strane FPGA koristi se Avalon magistrala, stoga je neophodan AXI-Avalon bridge.

\subsubsection{Proces pokretanja HPS (boot)}
Pokretanje HPS je proces koji se obavlja u više koraka. Nakon izvršavanja svakog koraka se učitava i pokreće sledeći. Ovo je proces je sličan kod svih ARM procesora, a u nastavku je ukratko opisan za konkretnu platformu.

\begin{figure}[h!]
\centering
\includegraphics[scale=1.]{img/gsrd-boot.png}
\caption{Tok pokretana sistema}
\label{slika1:gsrd}
\end{figure}

Pri izlazu iz reset stanja procesor počinje izvrsavanje sa reset vektora iz memorije na čipu. Na adresi reset vektora je upisan Boot ROM progtam. Ovo je prvi korak u pokretanju HPS. \textit{Boot ROM} izvršava osnovna podešavanja procesora i dohvata \textit{preloader} iz NOR \textit{flash} memorije, NAND \textit{flash} memorije ili SD/MMC \textit{flash} memorije. Očitavaju se BSEL pinovi na osnovu kojih se određuje gde je smešten \textit{preloader}, zatim se inicijalizuje taj interfejs i učitava i pokreće \textit{preloader}. \textit{Boot ROM} softver proizvođača i ne može se menjati. 

\textit{Preloader} je prvi korak u pokretanju koji može da se konfiguriše. \textit{Preloader} obično izvršava inicijalizaciju SDRAM, dodatna podešavanja sitema, inicijalizaciju \textit{flash} kontrolera koji sadrži sledeći program (NAND, SD/MMC, QSPI) i zatim učitavanje programa u RAM memoriju i pokretanje.

Softver koji sledi nakon \textit{preloader}-a može biti \textit{baremetal} aplikacija ili \textit{bootloader}. \textit{Preloader} i svi prethodni programi se izvršavaju na prvom jezgru procesora dok je drugo u reset stanju. Naredni koraci mogu inicijalizovati drugo jezgro.

\textit{Bootloader} ima zadatak da podesi promenljive okruženja operativnog sistema, dohvati fajlove za pokretanje operativnog sistema (sa \textit{flash} memorije, putem \textit{Etherneta} preko TFTP protokola ili USB), konfigurise FPGA pruži konzolu za korisničke operacije. Neki od populatnih \textit{open-source} \textit{bootloader}-a su U-Boot i Barebox.

\subsection{Alati}
U nastavku će ukratko biti opisani korišćeni alati sa izdvojenim najvažnijim mogućnostima:
\begin{itemize}
\item Quartus Prime 18.0 - alat za razvoj hardvera na FPGA. Deo paketa je Platform Designer (ranije Qsys) koji u dizajn ukljucuje HPS, IP blokove i definiše povezanost ovih delova
\item \textit{Preloader Generator} (\texttt{bsp-editor} alat iz SoC EDS) - Generiše izvorni kod \textit{preloader}-a na osnovi izlaznih fajlova koji opisuju hardver
\item \textit{Device Tree Generator} (\texttt{sopc2dts} alat iz SoC EDS) - Generiše \textit{Device Tree} opis hardvera na osnovi izlaznih fajlova koji opisuju hardver
\item \textit{DE1-SoC Builder} - Generise prazan \textit{Quartus} projekat za DE1-SoC razvojni sistem
\item \textit{Linaro Toolchain} - koristi se za kompajliranje softvera
\end{itemize}

Na slici \ref{slika1:gsrd} je grafički prikazan tok projektovanja jednog SoCFPGA sistema.

\begin{figure}[h!]
\centering
\includegraphics[scale=1.3]{img/gsrd-flow.png}
\caption{Tok projektovanja}
\label{slika1:gsrd}
\end{figure}

U nastavku su objašnjeni fajlovi koji se koriste pri projektovanju:
\begin{itemize}
\item \texttt{.qpf} - projektni fajl za Quartus. Ovaj fajl generiše DE1-SoC Builder
\item \texttt{.qsf} - skripta za podešavanje pinova. Ovaj fajl generiše DE1-SoC Builder
\item \texttt{.sdc} - skripta za podešavanje takta. Ovaj fajl generiše DE1-SoC Builder
\item \texttt{.v} - Verilog HDL izvorni kod
\item \texttt{.vhd} - VHDL izvorni kod
\item \texttt{.sof} -  SDRAM Object File - fajl za programiranje FPGA.  Ovaj fajl generiše Quartus pri kompajliranju dizajna
\item \texttt{.rbf} - \textit{Raw Binary File} - fajl za programiranje FPGA. Ovaj fajl se dobija konverzijom \texttt{.sof} alatom \texttt{quartus\_cpf}
\item \texttt{.dts} - \textit{Device Tree Source} - opis hardvera za Linuks kernel
\item \texttt{.dtb} - \textit{Device Tree Blob} - binarni fajl, kompajlirani opis hardvera za Linuks kernel
\item \texttt{.sopcinfo} - sadrži opis hardvera na osnovu kog se generišu drugi fajlovi. Ovaj fajl generiše \textit{Platform Designer}
\item \texttt{.c} - izvorni kod u jeziku C
\item \texttt{Makefile} - sadrži set direktiva za \texttt{make buld system}
\end{itemize} 
\pagebreak
\section{Opis projektovanog sistema}

U ovom radu je implementiran jednostavan sistem koji demonstira osnovne mogucnosti u dizajniranju sistema na SoC FPGA. Na slici \ref{slika:q3} je prikazan realizovani sistem (dodati novu sliku?)

\begin{figure}[h!]
\centering
\includegraphics[scale=0.9]{img/quartus3.png}
\caption{Blok šema sistema}
\label{slika:q3}
\end{figure}

\subsection{Memorijski mapiran interfejs ka LE diodama i tasterima u FPGA}
Za projektovanje hardvera u FPGA koristi se PIO (\textit{Parallel Input/Output}) Intel FPGA IP blok. Ovo je jedan od mnogih dostupnih Intelovih IP blokova sa standardizovanim \textit{Avalon Memory Mapped Slave} interfejsom. HPS sistem pristupa registrima ovog IP bloka preko svoje standardne AXI magistrale. Između Avalon i AXI magistrale nalazi se automatski generisani \textit{brige}.

PIO Intel FPGA IP blok ima mogućnost da se konfiguriše kao ulazni, izlazni ili bidirekcioni. Takođe postoji mogućnost generisanja prekida na uzlaznu, silazni ili obe ivice ulaznog signala kao i mogućnost generisanja prekida na osnovu nivoa ulaznog signala. Dostupna su podešavanja za širinu paralelnog porta.

U tabeli ref su opisani registri PIO Intel FPGA IP bloka.

PIO Intel FPGA IP je u ovom radu iskorišćen za jednostavnu demonstraciju tako što je povezan na pinove Cyclone V sistema na čipu koji su na DE1-SoC razvojnom sistemu povezani na LE diode i tastere. U slučaju konkretne primene na rešavanje nekog problema, PIO Intel FPGA IP pruža jednostavan memorijski mapiran interfejs i mogućnost slanja prekida iz FPGA dela. Ova mogućnost korisna je u slučaju kada je za rešeavanje datog problema pogodno implementirati prizvoljno rešenje u pogramabilnoj logici. Ovaj pristup pruža slobodu projektovanja sistema u programabilnoj logici, a sa druge strane se zadržava standardizovani interfejs prema kompleksnom sistemu procesora. Na primer, izlazi PIO Intel FPGA IP registara mogu se koristiti kao konfiguracioni registri koji će upravljati korisničkom logikom, kao način da se pogramabilnoj logici dostave podaci koji će zatim biti obrađeni i vraćeni nazad. Mogućnost slanja prekida koristna je kada se PIO Intel FPGA IP koristi za posmartanje toka izvršavanja algoritma u programabilnoj logici - na promenu nekog signala se generiše prekid i opcioni zatim očitava iz statusnog regisra potrebna informacija koja oslikava stanje sistema. Takođe, prekid se može koristiti za sinhronizaciju toka podataka pri obradi podataka u FPGA tj. kao vid da se mikroprocesoru javi da su podaci spremni za čitanje. Rezultati rešavanja problema u FPGA se mogu učinti dostupnim spoljnom svetu preko nekog od mnogih standardnih interfejsa (USB, Ethernet, UART, ...) i to vrlo jednostavnim postupcima u okviru operativnog sitema na HPS delu.

U ovom projektu u FPGA delu su postavljena dva PIO (\textit{Parallel Input/Output}) Intel FPGA IP bloka. PIO IP blok \texttt{leds\_0} je izlazni i koristi se za kontrolisanje LE dioda. PIO IP blok \texttt{keys\_0} je ulazni i koristi se za očitavanje tastera. PIO IP blok \texttt{keys\_0} takođe šalje prekidni zahtev HPS-u na svaku uzlaznu i silaznu ivicu.

\subsection{Preloader}
Pri pokretanju HPS sistema koristi se \textit{preloader} generisan Alterinim alatima. Za generisanje \textit{preloader}-a neophodni su fajlovi za opis sistema koje generiše Platform Designer. Program za generisanje \textit{Preloader Generator} je deo Alterinog SOC EDS(\textit{Embedded Development Suite}) paketa alata. U grafičkom meniju se odabira folder u kojem se nalazi Platform Designer projekat sistema za koji se generiše \textit{preloader}. Ovako generisani \textit{preloader} je zasnovan na SPL (\textit{Secondary Program Loader}) \textit{framework}-u koji je deo U-Boot projekta. Ovo ima pozitivnu posledicu da \textit{preloader} i U-Boot dele dosta izvornog koda, kao što je mnoštvo pouzdanih drajvera.

Standardne funkcija \textit{preloader}-a za Cyclone V sistem na čipu su:
\begin{itemize}
\item inicijalizacija SDRAM interfejsa uključujići kalibraciju SDRAM PLL modula
\item dohvatanje \textit{bootloader} binarnog fajla sa \textit{flash} memorije (NAND, SD/MMC, NOR)
\item smeštanje binarnog fajla \textit{bootloader}-a u SDRAM i prepuštanje toka izvršavanja
\item konfiguriše multipleksiranje pinova(podešavanja za konfiguraciju su dostupna u Platform Designeru)
\item konfiguriše PLL na osnovu korisničkih podešavanja dostupnih u \textit{preloader generator}-u
\item otpušta određene periferije iz stanja reseta (izbor periferija se konfiguriše u Platform Designer-u)
\item inicijalizuje \textit{flash} kontroler (bilo NAND, SD/MMC ili QSPI) na osnovu \textit{boot} prekidača
\end{itemize}

U ovom radu se \textit{preloader} koristi za učitavanje U-boot \textit{bootloader}-a. U-boot \textit{bootloader} se nalazi na SD kartici. DE1-SoC razvojni sistem je već podešen za pokretanje sistema sa SD kartice, stoga je preostalo u \textit{preloader generator}-u uključiti podršku za \textit{FAT file system} i definisati ime binarnog fajla \textit{bootloader}-a. Nakon konfigurisanja \textit{preloader}-a potrebno je kompajlirati izvšni fajl koji će se prebaciti na razvojni sistem. Kompajliranje se vrši jednostavnim pozivom \textit{make} naredbe koja pokreće skriptu za \textit{make build system} koja kao rezultat daje izvršni fajl.

Ovaj izvršni fajl je potrebno prebaciti na SD karticu na posebnu particiju. Prilikom particionisanja SD kartice neophodno je predvideti ovu particiju i podesiti njen tip na posebnu vrednost \texttt{a2}.

\subsection{Bootloader}
\textit{Open-source} projekat U-Boot (\textit{Universal Boot Loader}) je uobičajeni izbor \textit{bootloader}-a za namenske sisteme zasnovane na ARM, PowerPC, MIPS procesorima. U-Boot se u ovom radu koristi za programiranje FPGA i učitavanje operativnog sistema. Ovo se postiže zahvaljujući tome što U-Boot nudi korisniku komandnu liniju koja se jednostavno može koristiti za pisanje skripti za željeno ponašanje \textit{bootloader}-a.

U-Boot se preuzima u obliku izvornog koda sa \texttt{git}-a[ref na git]
https://github.com/u-boot/u-boot
"Das U-Boot" Source Tree
Kako U-Boot podržava različite arhitekture potrebno je izvršiti konfiguraciju softvera. Konfiguracija je dostupna kao gotova za mnoge razvojne sisteme. Izvorni kod se konfiguriše kroz Kbuild infrastrukturu koja je se takođe koristi za konfiguraciju Linuksa. Konfiguraciju ovim putem se poziva iz komandne linije i pruža vrlo jednostavan grafički interfejs i veliku moć podešavanja.

Konfiguracija za DE1-SoC razvojni sistem je dostupna kao gotova, što znači da se lako dobija funkcionalno konfigurisan izvorni kod na jednostavan način. Osim toga, ovom konfigracijom dostupne su komande programiranja FPGA dela preko \textit{FPGA Manager} periferije.

Nakon osnovnog konfigurisanja softvera potrebno je napisati skriptu za željeno ponašanje i konfigurisanje U-Boot da pri pokretanju izvrši tu skriptu. Kroz Kbuild sistem se menja vrednost promenljive \textit{bootcmd} koja sadrži komandu koja će biti izvršena odmah po pokretanju sistema ukoliko korisnik ne prekine ovaj proces. Promenljiva \textit{bootcmd} je podešena tako da se izvrši kratka skripta za učitavanje naredne korisničke skripte (podešena je komanda \textit{run callscript}). Dalje, u izvornom kodu je na mestu predviđenom za korisničke definicije definisana jednostavna skripta \textit{callscript} koja samo učitava narednu korisničku skriptu (nazvanu \textit{u-boot.scr}). Na ovaj način je ostavljena sloboda za izmenu skripte i time ponašanja \textit{bootloader}-a bez potrebe da se ponovo konfiguriše i kompajlira U-Boot.

Ovim je konfiguracija U-Boot \textit{bootloader}-a završena i zatim se vrši kompajliranje kako bi se dobio izvršni fajl. Za kompajliranje koristi se besplatni \textit{Linaro toolchain}.
\subsubsection{Skripta za U-Boot}
Skripta za U-Boot piše se kao tekstualni fajl u skladu sa U-Boot sintaksom. U-Boot komande pružaju velike mogućnosti u cilju pokretanja operativnog sistema. Uobičajene mogućnosti ovih komandi su:
\begin{itemize}
\item podešavanje promenljivih okruženja operativnog sistema
\item dohvatanje binarnih fajlova za pokretanje operativnog sistema iz \textit{flash} memorije ili preko \textit{ethernet}-a pri čemu je omogućen pristup standardnim fajl sistemima kao i prenos preko mreže preko TFTP(\textit{Trivial File Transfer Protocol})
\item smeštanje binarnih fajlova za pokretanje sistema u SDRAM i prepuštanje toka izvršavanja
\item podešavanje \textit{boot} argumenata koja se koriste za podešavanje kernela operativnog sistema
\end{itemize}

Nakon pisanja skripte potrebno je \textit{mkimage} alatom dodati odgovarajući U-Boot heder. Fajl koji se dobija je potrebno prebaciti na SD karicu na FAT particiju. U-Boot je već konfigurisan pre kompajliranja tako da učita i izvrši ovu skriptu.

U ovom radu skripta je napisana tako da programira FPGA i pokrene Linuks operativni sistem. Fajlovi koje U-Boot čita pri izvršavanju ove skripte su:
\begin{itemize}
\item \texttt{socfpga.rbf} - binarni za konfiguraciju FPGA
\item \texttt{socfpga.dtb} - binarni fajl koji opisuje hardversku platofrmu za Linuks kernel
\item \texttt{zImage} - kompajlirani kernel
\end{itemize}

U skripti se podešava vrednost promenljive \texttt{bootargs} koja definiše argumente koji će biti prosleđeni kernelu pri pokretanju operativnog sistema. Ova promenljiva podešena je tako da definiše veličinu RAM memorije, parametre konzole za komunikaciju sa sistemom i određuje definisanu \texttt{ext3} particiju SD kartice kao \textit{root file system} Linuksa.

Nakon učitavanja ovih fajlova izvršavaju se sledeće važne komande:
\begin{itemize}
\item \texttt{fpgaload} - za programiranje FPGA
\item \texttt{bridge enable} - za inicijalizaciju AXI magistrale između FPGA dela i HPS dela
\item \texttt{bootz} - komanda za pokretanje pokretanje operativnog sistema pri čemu se kernelu prosleđuje \textit{Devie Tree Blob} i argumenti iz promenljive \texttt{bootargs}
\end{itemize}

\subsection{Device Tree}
Device Tree ili skraćeno DT je struktura podataka koja opisuje hardver. Koristi se za identifikaciju platforme i podešavanje u toku izvršavanja kao što argumenti pri pokretanju kernela (promenljiva \textit{bootargs} koja je pomenuta ranije). Ovaj način organizacije je uveden iz potrebe da se standardizuje način pokretanja kernela i interfejs između \textit{bootloader}-a i kernela i omogućilo jednostavno dodavanje novih platofrmi. Tako na primer jednom kompajlirani kernel može da se koristi na različitim platformama. Device Tree Source koji opisuje detalje hardvera se kompajlira alatom Device Tree Compiler u binarni fajl Device Tree Blob. Device Tree Blob učitava \textit{bootloader} i prosleđuje kernelu.
\subsubsection{Struktura Device Tree}
Device Tree struktura podataka je organizovana kao drvo tako da se sastoji od čvorova (\textit{node}). Svaki čvor u ovoj strukturi mora imati čvor koji se nalazi iznad njega u hijerarhiji (\textit{parent node}) osim korena stabla (\textit{root node}). Svaki čvor predstavlja jedan drajver ili modul i sadrži opis osobine. Ukoliko postoje pravila za organizaciju informacija unutar čvora ona su opisana u \textit(bindings) delu u Linuks dokumentaciji[https://github.com/torvalds/linux/tree/master/Documentation/devicetree/bindings] Device Tree ne mora da opiše svaki deo hardvera, a čvorovi koji su uobičajeni opisuju:
\begin{itemize}
\item procesori sistema (ovaj čvor je neophodan po specifikaciji)
\item memorije sistema (ovaj čvor je neophodan po specifikaciji)
\item specijalni konfiguracioni čvor za podešavanje argumemnata pri pokretanju kernela, podrazumevanih ulazno/izlaznih uređaja (ovaj čvor je neophodan po specifikaciji)
\item čvor koji opusje generalne osobine sistem na čipu (ovaj čvor je neophodan ukoliko je procesor u sistemu na čipu)
\item čvorovi koji opisuju magistrale sistema (ovaj čvor nije neophodan ali se preporučuje)
\end{itemize}

Neke od vaznih osobina u čvoru su:
\begin{itemize}
\item \texttt{compatible} - koristi se da označi kompatibilnost uređaja sa porodicom sličnih uređaja i za uparivanje drajvera i uređaja
\item \texttt{reg} - opisuje deo adresnog prostora u kom se nalazi uređaj kao par: početna adresa i dužina adresnog opsega
\item \texttt{#address-cells} - određuje koliko 32-bitnih ćelija se koristi za opis početne adrese u \texttt{reg}
\item \texttt{#size-cells} - određuje koliko 32-bitnih ćelija se koristi za opis dužine adresnog opsega u \texttt{reg} polju
\item \texttt{interrupts} - koristi se za uređaje koji generišu prekid i opisuje najčešće broj prekida i tip (nivo/ivica)
\item \texttt{interrupt-parent} - koristi se za uređaje koji generišu prekid i pokazuje na kontroler prekida kojem se šalje prekidni zahtev
\item \texttt{interrupt-controller} - \texttt{boolean} vrednost koja označava da li je uređaj kontroler prekida
\item \texttt{#interrupt-cells} - određuje koliko 32-bitnih ćelija se koristi za opis \texttt{interrupts} polja u uređajima koji koriste kontroler prekida
\end{itemize}

U nastavku(premestiti u dodatak?) je na primeru dat pojednostavljeni Device Tree Source koji opisuje DE1-SoC razvojni sistem. Na osnovu prethodnog tekst se lako može razumeti organizacija sistema. Pojednostavljenje ovog primera se svodi na izostavljanje uređaja sistama na čipu čiji rad se ne izučava u ovom radu. Ceo Device Tree je podeljen u nekoliko fajlova i može se pronaći u literaturi[]socfpga_cyclone5_socdk.dts socfpga_cyclone5.dtsi socfpga.dtsi Iz priloženog koda se vidi da se sistem sastoji od:
\begin{itemize}
\item dva procesorska jezgra Cortex-A9
\item standardni ulazno/izlazni uređaj je serijski uređaj \texttt{serial0}
\item RAM memorija je kapaciteta 1GB
\item koristi se kontroler prekida  ARM Generic Interrupt Controller
\item na memorijskoj adresu \texttt{0xff200000} koja odgovara početku adresnog prostora AXI magistrale koji izlazi prema FPGA se nalazi korisnički hardver koji se implementira u ovom radu i zauzima adresni opseg dužine 32 memorijske lokacije, prekidni zahtev je pod brojem 40 i ostljiv je na uzlaznu i silaznu ivicu
\item \texttt{serial0} je periferija \texttt{uart0} na naznačenoj adresi i sa naznačenim brojem prekida
\end{itemize}
\begin{lstlisting}[language=C]
/ {
	#address-cells = <1>;
	#size-cells = <1>;
	
	cpus {
		#address-cells = <1>;
		#size-cells = <0>;

		cpu0: cpu@0 {
			compatible = "arm,cortex-a9";
			device_type = "cpu";
			reg = <0>;
		};
		cpu1: cpu@1 {
			compatible = "arm,cortex-a9";
			device_type = "cpu";
			reg = <1>;
		};
	};
	
	chosen {
		bootargs = "earlyprintk";
		stdout-path = "serial0:115200n8";
	};

	memory@0 {
		name = "memory";
		device_type = "memory";
		reg = <0x0 0x40000000>; /* 1GB */
	};

	intc: intc@fffed000 {
		compatible = "arm,cortex-a9-gic";
		#interrupt-cells = <3>;
		interrupt-controller;
		reg = <0xfffed000 0x1000>,
		      <0xfffec100 0x100>;
	};
	soc {
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "simple-bus";
		device_type = "soc";
		interrupt-parent = <&intc>;
		ranges;
		
		lddipl0: lddipl@0xff200000 {
			compatible = "ld,dipl";
			reg = <0xff200000 0x00000020>;
			interrupts = <0 40 1>;
			
		uart0: serial0@ffc02000 {
			compatible = "snps,dw-apb-uart";
			reg = <0xffc02000 0x1000>;
			interrupts = <0 162 4>;
		};
\end{lstlisting}

Kada je Device Tree Source napisan potrebno je smestiti \texttt{.dts} fajl u folder \{arch/arm/boot/dts/}. Kompajliranje izovrnog opisa u binarni fajl Device Tree Blob se ivršava komandom \texttt{make *.dtb} gde je potrebno upisati naziv fajla koji se kompajlira.

Potrebno je napomenuti da je u ovom radu modifikovan Device Tree za razvojni sistem Cyclone V Develompent Kit koji je veoma sličan DE1-SoC. Uvedene modifikacije se svode na isključivanje CAN uređaja koji Cyclone V Develompent Kit ima a DE1-SoC nema. Zatim je dodat opis implementiranih PIO Intel FPGA IP u FPGA. Drugi način dobijanja Device Tree koji nije zahtevao ručnu modifikaciju je korišćenje Device Tree Generator-a koji je dostupan u okviru Altera Embedded Develompment Suite paketa softverskih alata.Za ovaj način je testiranjem utvrđeno da postoji problem: naime, drajver ne vidi uređaje koji pripadaju čvoru \texttt{bridge} koji opisuje adresni prostor između FPGA i HPS i samim tim i generisani hardver u FPGA. Razlog ovome je najverovatnije različita verzija kernela od one za koju je alat namenjen, ali je u skladu sa edukativnim ciljem ovog rada izabran put ručnog pisanja Device Tree umesto korišćenja generisanog.

\subsection{Linuks kernel}

Izvorni kod za Linuks kernel je preuzet za Alterinog \texttt{git}-a. \textit{Root file system} je generisan korišćenjem \texttt{buildroot}-a i upisan na SD karticu.

\subsection{Drajver}
Drajver imaju specijalnu ulogu u Linuks kernelu. Drajver je deo sistema koji obezbeđuje da deo hardvera radi na očekivani način preko jednostavno definisanog programerskog interfejsa, pri čemu se krije kompleksnost detalja rada hardvera. Korisničke aktivnosti se svode na jednostavne pozive nezavisno od vrste drajvera, a ti pozivi se preslikavaju na operacije specifične za svaki drajver koje deluju na pravom hardveru. Drajveri su oraganizovani kao moduli kernela tako da se razvijaju odvojeno i mogu se uključiti u kernel po potrebi. Moduli po učitavanju postaju deo kernela tako da imaju pristup \texttt{kernel space}-u a komunicijaru sa \texttt{user space}-om preko određenog interfejsa.

\subsubsection{Linux Device Model}
Linux Device Model je novi standard koji uvodi apstrakcije o sastavu sistema. Pre ovoga nije postojala jedna struktura koja opisuje način na koji je sistem sastavljen. Ove apstakcije izdvajaju sličnosti uređaja i grupišu ih nezavisno od specifične implementacije. Linux Device Model nudi podršku za različite zadatke kao što su: upravljanje potrošnjom, komunikacija sa \texttt{user space}-om, priključivanje uređaja tokom rada (\textit{hotplud, plug-n-play}), podela urešaja u klase. Bitne komponente Linux Device Model-a su udev, sysfs, kobject i klase uređaja.

\texttt{sysfs} je virtuelni fajl sistem koji pruža interfejs ka strukturama kernela. Ovaj fajl sistem prikazuje strukturu Linux Device Model-a  i se obično nalazi u folderu \texttt{sys}.  Fajlovi u \texttt{sysfs}  pružaju informacije o uređajima, modulima kernela, fajl sistemima i drugim komponentama kernela. Većina fajlova može samo da se čita kako bi se dobile informacije o kernelu, dok su neki namanjeni i za upis što dozvoljava izmene u kernelu. Kako bi se izbegla redudantnost dosta se koristi simboličko linkovanje, pri čemu jedan fajl predsavlja samo link ka mestu gde se taj fajl zapravo nalalzi. Svaki fajl zasnovan je na strukturi \texttt{kobject} koja nudi neke opšte osobine koje se koriste kod svih objekata.  \texttt{kobject} se retko koristi sam po sebi već je obično deo neke veće strukture i samim tim se i operacije sa  \texttt{kobject}-om kriju iza programerskog interfejsa. 

Kao što je pomenuto, svi uređaji su predstavljeni kao jedan fajl u folderu \texttt{dev}. \texttt{udev} ima zadatak da dodaje uređaje u ovaj folder. \texttt{udev} se oslanja na informacije iz \texttt{sysfs}.

Klase uređaja grupišu uređaje po funkcionalnosti a ne prema načinu povezivanja i implementacije. Unutar foldera \texttt{class} se nalaze klase koje grupišu uređaje u terminale, mrežne uređaje, grafičke uređaje, zvučne urešaje itd. U ovim folderima se nalaze simobličke veze ka unosima u folderu \texttt{devices} u kojem se nalazi opis Device Tree kernela. 

\subsubsection{Implementacija drajvera}

Drajver je napisan kao modul kernela. Drajver pripada \texttt{platform} magistrali. Ovo je pseudo magistrala minimalne infrastrukture koja se koristi za memorijski mapirane uređaje kojima se može pristupiti direktno preko magistrale procesora. Ova magistrala je uobičajeni izbor za namenske sisteme, pogotovo kada se implementira drajver za neku posebnu namenu kao što je FPGA periferija u slučaju ovog rada. Implementirani \textit{platform} drajver se koristi za dohvatanje informacija o uređaju iz Device Tree strukture, za registrovanje prekidne rutine i za stvaranje \texttt{sysfs} fajlova koji korisniku pružaju jednosavan interfejs prema hardveru.

\subsubsection*{modul kenrela}
Važni delovi svakog modula kernela su:
\begin{itemize}
\item makro definicije za osnovne informacije o modulu kao što su ime autora, opis, licenca, verzija modula
\item \{init} funkcija koja se izvršava pri učitavanju modula u kernel
\item \{exit} funkcija koja se izvršava pri uklanjanju modula iz kernela
\end{itemize}

U funkcijama \{init} i \{exit} se pozivaju funkcije sa registrovanje \textit{platform} drajvera.

\subsubsection*{Platform drajver}
Platform drajver se definiše jednostavnom strukturom čija su polja:
\begin{itemize}
\item \texttt{probe} - pokazivač na funkciju koja će biti pozvana pri uspešnom registrovanju drajvera
\item \texttt{remove} - pokazivač na funkciju koja će biti pozvana pri uklanjanju drajvera
\item \texttt{driver} - sadrži informacije o imenu drajvera i pokazivač na \texttt{of_device_id} koja identifikuje drajver u Device Tree na osnovu \texttt{compatible} polja (neophodno je da se vrednosti definisane u drajveru i u Device Tree poklope kako bi se uspešno registrovao drajver)
\end{itemize}

Funkcije \texttt{probe} i \texttt{remove} se koriste za dohvatanje informacija iz Device Tree i potrebna podešavanja:
\begin{itemize}
\item dohvataju se adresa početka i dužina memorijskog opsega periferije pozivom funkcije \texttt{platform_get_resource} i zatim se taj opseg mapira pozivom funkcije \texttt{ioremap}
\item dohvata se broj prekida pozivom funckije \texttt{get_platform_irq} i zatim se registruje prekidna rutina pozivom funkcije \texttt{requset_irq}
\end{itemize}

Dalje se prave \texttt{sysfs} fajlovi.

\subsubsection*{sysfs fajlovi}
\texttt{sysfs} se koristi kao jednostavan intefrejs prema \texttt{user space}-u. Stvaranje fajlova se u drajveru svodi na jednostavno pisaje funkcija \texttt{.show} za čitanje i \texttt{.store} za upis. Ovim izborom se postiže jednostavno pisanje drajvera sa jednostavnim programerskim intefrejsom, dok su alternativni načini bili pisanje \texttt{char} drajvera, stvaranja unosa u klasu uređaja ili upotreba nekog standardnog \texttt{framework}-a za ovu konkretnu primenu kao što je GPIO, LED.

Stvoreni fajlovi se pojavljuju u folderi koji je se nalazi u {/sys/bus/platform/driver/lddipldrv}. Sistemski fajlovi koje pravi drajver i njihov opis:
\begin{itemize}
\item \texttt{leds} - broj upisan u ovaj fajl se prikazuje na LE diodama u binarnoj predstavi
\item \texttt{keys} - čitanje iz ovog fajla vraća binarnu predstavu stanja tastera
\item \texttt{irq\_flag} - pristup registru za flegove prekida (1 na n-tom bitu označava pristigli prekid na n-tom tasteru, upis 1 na n-ti bit čisti n-ti fleg)
\item \texttt{irq\_mask} - čitanje i upis u registar za maksiranje prekida (upis 1 na n-ti bit omogućava prekid na n-tom tasteru)
\end{itemize}

Ovi fajlovi se mapiraju u pozive funkcija koje ivršavaju jednostavne upise i čitanje u registre. Za detalje o radu drajvera pogledati ceo kod drajvera koji je dostupan u dodatku.
\subsection*{Testiranje sistema}
Binarni fajlovi za pokretanje sistema i root fajl sistem su napisani na SD karticu. HPS je povezan sa PC računarom preko UART-USB serijske veze. Otvaranjem konzole na PC računaru se pristupa sistemu.\\
U nastavku je dat komplatan spisak koraka za realizovanje sistema.



