\documentclass[12pt, a4paper]{article}

%paketi
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
%\usepackage[serbian]{babel}
\usepackage{fullpage}
%\usepackage{amsmath}
%\usepackage{hyperref}
\usepackage[margin=2cm]{geometry}
\usepackage{graphicx}
%\linespread{1.3}
\input{listingconfig.tex}
\begin{document}

\input{naslovna.tex}

%\tableofcontents
%\pagebreak

\section{Priprema okruženja}

Sa sajta premeta skinuti fajlove: \\
\verb%pds9-priprema.sh, pds41.patch, pds_proj_files.tar.gz%. Zatim izvršiti skriptu (izabrati preuzimanje sa gita), otpakovati arhivu i podesiti promenljive okruzenja:

\begin{lstlisting}[language=C]
bash pds9-priprema.sh
tar xf pds_proj_files.tar.gz
source ~/env.sh
\end{lstlisting}

\section{QEMU}
QEMU se patch-uje za potrebe projekta.
\begin{lstlisting}[language=C]
$ cd qemu
$ patch -p1 < ../pds41.patch
\end{lstlisting}

Zatim je potrebno kompajlirati QEMU.
\begin{lstlisting}[language=C]
$ cd bin/arm
$ make -j4
\end{lstlisting}
Sada je dostupna nova mašina u QEMU na kojoj se radi projekat.
\begin{lstlisting}[language=C]
$ qemu-system-arm -machine ?
Supported machines are:
[...]
vexpress-pds41       ARM Versatile Express for PDS Project 41
[...]
\end{lstlisting}

\section{U-Boot}
Radi se u folderu uboot.
\begin{lstlisting}[language=C]
$ cd uboot
\end{lstlisting}
Počinje se od default konfiguracionog fajla koji se prilagođava projektu:
\begin{lstlisting}[language=C]
$ sudo cp configs/vexpress_ca9x4_defconfig\
configs/vexpress_ca9x4_pds_defconfig
\end{lstlisting}
U novom konfiguracionom fajlu \verb%configs/vexpress_ca9x4_pds_defconfig% se unosi izmena :
\begin{lstlisting}[language=C]
[...]
CONFIG_TARGET_VEXPRESS_CA9X4_PDS=y
[...]
\end{lstlisting}
Za konfiguraciju \verb%CONFIG_TARGET_VEXPRESS_CA9X4_PDS% je potrebno dodati sledeće u \\
\verb%board/armltd/vexpress/Kconfig%:
\begin{lstlisting}[language=C]
[...]
if TARGET_VEXPRESS_CA9X4_PDS

config SYS_BOARD
	default "vexpress"

config SYS_VENDOR
	default "armltd"

config SYS_CONFIG_NAME
	default "vexpress_ca9x4_pds"

endif
\end{lstlisting}
Ime heder fajla koji će se koristiti je \verb%vexpress_ca9x4_pds%.
Za novu konfiguraiju \\
\verb%CONFIG_TARGET_VEXPRESS_CA9X4_PDS% je potrebno dodati u fajl \\
\verb%arch/arm/Kconfig%:
\begin{lstlisting}[language=C]
config TARGET_VEXPRESS_CA9X4_PDS
	bool "Support vexpress_ca9x4"
	select CPU_V7
\end{lstlisting}
Novi heder se nalazi na \verb%include/configs/vexpress_ca9x4_pds.h%:
\begin{lstlisting}[language=C]
#ifndef __VEXPRESS_CA9X4_PDS_H
#define __VEXPRESS_CA9X4_PDS_H

#define CONFIG_VEXPRESS_ORIGINAL_MEMORY_MAP
#include "vexpress_common.h"

#endif /* VEXPRESS_CA9X4_H */
\end{lstlisting}
U hederu \verb%include/configs/vexpress_common.h% se unose izmene za novu konfiguraciju \\
\verb%__VEXPRESS_CA9X4_PDS_H%. Ovde su unete izmene adrese periferija MMCI, UART0, TIMER01:
\begin{lstlisting}[language=C]
#ifdef __VEXPRESS_CA9X4_PDS_H
[...]
#define V2M_MMCI		(V2M_PA_CS7 + V2M_PERIPH_OFFSET(14)) /*edited*/
#define V2M_UART0		(V2M_PA_CS7 + V2M_PERIPH_OFFSET(13)) /*edited*/
#define V2M_TIMER01		(V2M_PA_CS7 + V2M_PERIPH_OFFSET(5)) /*edited*/
[...]
#else
[...]
#endif
\end{lstlisting}
Ovim izmenama je U-Boot spreman za korišćenje na novoj ploči. Sada se vrši konfiguracija i kompajliranje pokretanjem komadni:
\begin{lstlisting}[language=C]
$ make CROSS_COMPILE=arm-linux-gnueabihf- vexpress_ca9x4_pds_defconfig
$ make CROSS_COMPILE=arm-linux-gnueabihf-
\end{lstlisting}

\section{Kernel}
Portovanje kernela se svodi na izmenu Device Tree fajlova. Počinje se od postojećeg \verb%dts% fajla:
\begin{lstlisting}[language=C]
cp /arch/arm/boot/dtsvexpress-v2p-ca9.dts \
/arch/arm/boot/dtsvexpress-v2p-pds.dts
\end{lstlisting}
Potrebni fajlovi se integrišu u jedan \verb%dts% fajl. Ovo se postiše kopiranjem sadržaja fajl\\
 \verb%/arch/arm/boot/vexpress-v2m.dtsi% na mesto \verb%/include/ "vexpress-v2m.dtsi"% u fajlu\\
  \verb%/arch/arm/boot/dtsvexpress-v2p-pds.dts%. 
Unose se izmene u adresama za periferije \\
\verb%mmci@e000,v2m_timer01: timer@5000,v2m_serial0: uart@d000 i pdsdemo@15000%. Za komponentu \verb%pdsdemo% se upisuje:
\begin{lstlisting}[language=C]
			pdsdemo@15000 {
				compatible = "pds,demo";
				reg = <0x15000 0x1000>;
				interrupts = <28>;
			};
\end{lstlisting}
Kako bi se novi Device Tree fajl kompajlirao potrebno je dodati u \verb%arch/arm/boot/dts/Makefile% upisati:
\begin{lstlisting}[language=C]
dtb-$(CONFIG_ARCH_VEXPRESS) += \
	vexpress-v2p-ca5s.dtb \
	vexpress-v2p-ca9.dtb \
	vexpress-v2p-ca15-tc1.dtb \
	vexpress-v2p-pds.dtb \
	vexpress-v2p-ca15_a7.dtb
\end{lstlisting}
Kompajlirenje se vrši komandom:
\begin{lstlisting}[language=C]
$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- dtbs
\end{lstlisting}
Putanja do novog Device Tree binarnog fajla se smešta u promenljivu:
\begin{lstlisting}[language=C]
$ export PDS_DTB=/home/dejan/Downloads/linux-stable/arch/arm/boot/dts\
	/vexpress-v2p-pds.dtb
\end{lstlisting}

\section{Drajver}
Razviti platform character device drajver za akvizicionu periferiju. Ofseti registara i pozicije bitova unutar regisara su sledeće:
\begin{lstlisting}[language=C]
#define PDS_DEMO_COMP_CTRL_OFFSET	(0x00)
#define PDS_DEMO_COMP_STATUS_OFFSET	(0x04)
#define PDS_DEMO_COMP_DATA_OFFSET	(0x08)

#define CTRL_EN_MASK			(0x00000001<<16)
#define CTRL_IEN_MASK		(0x00000001<<17)
#define CTRL_SSPEED_MASK		(0x00000003<<18)
#define CTRL_SSPEED_NORMAL	(0x00000000)
#define CTRL_SSPEED_SLOW	(0x00000001<<18)
#define CTRL_SSPEED_FAST	(0x00000002<<18)
#define STATUS_IFG_MASK	(0x00000001<<17)

#define DATA_MASK		(0x0000FFFF)
\end{lstlisting}
Drajver je napisati u fajlu \verb%pds-demo.c% po ugledu na drajver sa sajta predmeta \verb%etf-demo.c%.

Drajver je integrisan u kernel. Za ovo je potrebno kopirati napisani .c fajl drajvera u folder:
\begin{lstlisting}[language=C]
sudo cp pds-demo.c linux-stable/drivers/char
\end{lstlisting}
Izmeniti konfiguracioni fajl \verb%drivers/char/Kconfig% 
\begin{lstlisting}[language=C]
[...]
config PDS_PROJ
	tristate "PDS41 device driver"
	depends on ARCH_VEXPRESS
	default y
	help
		This is PDS project 41 device driver.
endmenu
\end{lstlisting}
U mejkfajlu \verb%drivers/char/Makefile% dodati izmenu kako bi se kompaklirao drajver:
\begin{lstlisting}[language=C]
[...]
obj-$(CONFIG_PDS_PROJ)		+= pds-demo.o
\end{lstlisting}
Potrebno je kompajlirati krenel komandama:
\begin{lstlisting}[language=C]
$make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- oldconfig
$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4 zImage
\end{lstlisting}

\section{Kompajliranje sqlite3}
Za korisničku aplikaciju koristiće se jednostavna baza podataka. Preuzimanje sqlite3 i otpakivanje:
\begin{lstlisting}[language=C]
$ wget https://www.sqlite.org/2015/sqlite-autoconf-3081101.tar.gz
$ tar xf sqlite-autoconf-3081101.tar.gz
$ cd sqlite-autoconf-3081101
\end{lstlisting}

Zatim je potrebno kroskompajlirati sqlite3. Instaliracija se vrši u sistemski folder kroskompajlera kako bi fajlovi bili dostupni pri kroskompajliranju aplikacije kao i u pripremni direktorijum roof fajls sitema kako bi bili dostupni pri izvršavanju aplikacije:
\begin{lstlisting}[language=C]
$ CC=arm-linux-gnueabihf-gcc ./configure --host=arm-linux-gnueabihf -prefix=/usr
$ make
$ make DESTDIR=$(arm-linux-gnueabihf-gcc -print-sysroot) install
$ make DESTDIR=$STAGING install
\end{lstlisting}

\section{Aplikacija}
Razviti korisničku aplikaciju koja komunicira sa drajverom i bazom podataka. Korišcenjem C API funkcija potrebno je kreirati bazu podataka u /www/test.db i kreirati tabelu Samples.

Aplikacija po startovanju pokreće periferiju i dozvoljava
prekid upisom u odgovarajuće sysfs fajlove, nakon čega ulazi u
beskonačnu petlju gde se blokira čekajući novi podatak od periferije. 
\begin{lstlisting}[language=C]
[...]
/* otvaranje baze */
rc = sqlite3_open("/www/test.db", &db);
rc = sqlite3_exec(db, sql , 0, 0, &err_msg);

/* ukljucivanje periferije */
fd = open("/sys/class/pds/pdsdemo0/enable", O_WRONLY);
write (fd, &d, 1);
close(fd);
        
/* dozvola prekida */
fd = open("/sys/class/pds/pdsdemo0/enable_irq", O_WRONLY);
write (fd, &d, 1);
close(fd);

/* otvaranje fajla za poliranje */
sysfs_fd = open("/sys/class/pds/pdsdemo0/data", O_RDONLY);
pfd.fd = sysfs_fd;
pfd.events = POLLPRI|POLLERR;
\end{lstlisting}
Po prijemu novog podatka rezultat se konvertuje u ampere i zajedno sa trenutnim vremenom upisuje u bazu podataka.
\begin{lstlisting}[language=C]
while (1) {
        ret = poll(&pfd, 1, -1);
        if (ret > 0) {
                ret = read(pfd.fd, buffer, sizeof(buffer));
                printf("data = %s\n", buffer);
                value = atoi(buffer)/10000.0;
                sprintf(query , "INSERT  INTO  Samples(Time , Data) VALUES  (%u,%f);", (unsigned)time(NULL), value);
                rc = sqlite3_exec(db, query , 0, 0, &err_msg);
                lseek(pfd.fd, 0, SEEK_SET);
                }
        }
\end{lstlisting}
Za kompajliranje aplikacije sa dinamickim povezivanjem potrebnih biblioteka je napisan mejkfajl:
\begin{lstlisting}[language=C]
CC=arm-linux-gnueabihf-gcc
MCPU=cortex-a9

CFLAGS=-g -mcpu=${MCPU}
LDFLAGS=-lsqlite3 -ldl -lpthread

OBJS=app-pds41.o

all: app-pds41

app-pds41: ${OBJS}
        ${CC} ${CFLAGS} $? -o $@ ${LDFLAGS}

.PHONY: clean

clean:
        rm -f *.o
        rm -f app-pds41
\end{lstlisting}

Kompajliranje aplikacije i kopiranje u pripremni direktorijum:
\begin{lstlisting}[language=C]
$ make
$ sudo cp app-pds41 $STAGING/root/
\end{lstlisting}

Provera potrebnih biblioteka:
\begin{lstlisting}[language=C]
$ arm-linux-gnueabihf-readelf -d app-pds41 | grep NEEDED
0x00000001 (NEEDED)                     Shared library: [libsqlite3.so.0]
 0x00000001 (NEEDED)                     Shared library: [libdl.so.2]
 0x00000001 (NEEDED)                     Shared library: [libpthread.so.0]
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
$ cd $SYSROOT
$ arm-linux-gnueabihf-readelf -d lib/libdl.so.2 | grep NEEDED
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x00000001 (NEEDED)                     Shared library: [ld-linux-armhf.so.3]
$ arm-linux-gnueabihf-readelf -d lib/libc.so.6 | grep NEEDED
 0x00000001 (NEEDED)                     Shared library: [ld-linux-armhf.so.3]
$ arm-linux-gnueabihf-readelf -d lib/libpthread.so.0 | grep NEEDED
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x00000001 (NEEDED)                     Shared library: [ld-linux-armhf.so.3]
$ arm-linux-gnueabihf-readelf -d usr/lib/libsqlite3.so.0 | grep NEEDED
 0x00000001 (NEEDED)                     Shared library: [libdl.so.2]
 0x00000001 (NEEDED)                     Shared library: [libpthread.so.0]
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
$ sudo cp lib/libdl.so.2 $STAGING/usr/lib/
$ sudo cp lib/libpthread.so.0 $STAGING/usr/lib/
$ sudo cp lib/libc.so.6 $STAGING/usr/lib/
$ sudo cp lib/ld-linux-armhf.so.3 $STAGING/usr/lib/
$ sudo cp lib/libdl.so.2 $STAGING/usr/lib/
\end{lstlisting}

\section{Pokretanje}
U-Boot skripta se koristi za automatizaciju učitavanja fajlova sa sd kartice i pokretanje kernela.
\begin{lstlisting}[language=C]
setenv bootargs "root=/dev/mmcblk0p2 init=/sbin/init console=ttyAMA0"
fatload mmc 0:1 61000000 /zImage
fatload mmc 0:1 62000000 /vexpress-v2p-pds.dtb
bootz 61000000 - 62000000
\end{lstlisting}
Skriptu konvertovati u skriptu za U-Boot:
\begin{lstlisting}[language=C]
$ mkimage -A arm -T script -C none -n "PDS Boot Script.scr" -d boot.txt boot.scr
$ export BOOTSCR=$PWD/boot.scr
\end{lstlisting}
U pripremni direktorijum je potrebno kopirati fajlove za web sajt.
\begin{lstlisting}[language=C]
$ mkdir $STAGING/www
$ sudo cp pds_proj_files/cgi-bin $STAGING/www
\end{lstlisting}
Potrebno je napisati konfiguracioni fajl za httpd:
\begin{lstlisting}[language=C]
tee -a etc/httpd.conf <<EOF
A:192.168.10
/www/cgi-bin:admin:PDS
.html:text/html
EOF
\end{lstlisting}
Napraviti SD karticu sa dve particije \verb%boot% i \verb%rootfs%. Na particiju \verb%boot% kopirati zImage kernela, Device Tree binarni fajl i boot skriptu za U-Boot.
\begin{lstlisting}[language=C]
$ bash pds-create-sdcard.sh
$ bash pds-mount-sdcard.sh sd.img
$ sudo cp $ZIMAGE /mnt/boot/
$ sudo cp $PDS_DTB /mnt/boot/
$ sudo cp $BOOTSCR /mnt/boot/
\end{lstlisting}

Zatim na \verb%rootfs% kopirati sadržaj pripremnog direktorijuma i izbaciti karticu.
\begin{lstlisting}[language=C]
$ cd $STAGING
$ sudo cp -ar * /mnt/rootfs
$ sudo chown -R 0:0 /mnt/rootfs/
$ bash pds-mount-sdcard.sh sd.img
\end{lstlisting}

Pokrenuti virtuelnu mrežu izvršavanjem skripte \verb%pds-enable-qemu-network.sh%.

Pokrenuti QEMU sa mrežnim interfejsom i SD karticom izvršavanjem komande:
\begin{lstlisting}[language=C]
$ qemu-system-arm -M vexpress-pds41 -m 1G -kernel $UBOOT \
-nographic -net nic -net tap,ifname=tap0,script=no -sd sd.img
\end{lstlisting}
 
Nakon pokretanja sistema mount-ovati fajl sistem sa dozvolom za upis,
\begin{lstlisting}[language=C]
$ mount -o remount,rw /
\end{lstlisting}
Podići mrežni interfejs (ako je bio podignut prvo ga spustiti komandom \verb%ifdown%):
\begin{lstlisting}[language=C]
$ ifup eth0
\end{lstlisting}
Pokrenuti httpd server komandom
\begin{lstlisting}[language=C]
$ httpd -p 80 -h /www
\end{lstlisting}
Pokrenuti aplikaciju:
\begin{lstlisting}[language=C]
$ ./app-pds41
\end{lstlisting}
Na host računaru u pretraživaču otvoriti stranicu na adresi \verb%http://192.168.10.101/cgi-bin/samples%




\end{document}